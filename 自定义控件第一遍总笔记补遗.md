- 随着软件行业发展，现在又出现了一个安卓的新职位：
- 安卓特效开发工程师	全是关于自定义控件的
- 自定义控件甚至能开发一个小游戏
- View的继承树  20个合格，越多越钱多
- EXCEL里可以放入好多张图片，可以当一个揣摩图片组合的工具软件用
- 所有的ImageView区域都是矩形，就算是图片本身不是，点击那些空白的地方也会相应本控件点击事件
- 如果互相有遮挡，但仍然要正确地分别相应点击事件，就要考虑用相对布局，并让最小的控件在最上面，最大的
- 控件在最上面
- 想让一个控件在另一个控件右上角，这个控件需要和上一个控件靠左侧对齐alingLeft，并且位于其上 above，最后添加一些marging left和bottom的值。
- 希望点击按钮实现某些功能，开发中一般复写onkeyDown方法
- KeyEvent.keyCode_MENU是指软菜单按键		KeyEvent.keyCode_M是指物理菜单的按键
- animation动画只是假象，只是将控件变透明了，空白处还能点。动画结束后，能响应点击事件的，还是原来的位置，不是
- 结束后停留的新位置
- 安卓代码里，view组件setfoucusable setClickable setEnable setVisibility等都是独立的，并不是说View.GONE了
- 就不能获取焦点。虽然有些反常识，但源码就是这么做的。
- 解决办法：for循环遍历所有的子view，挨个setEnable	然后在show的时候再挨个恢复
- ViewPager里instantiateItem的ViewGroup container参数，其实就是ViewPager自身，所以才要把自己需要的View
- add到container里面
- 这个方法不一定非要返回view，只需要返回和当前view相关的object即可
- 接下来的isViewFromObject方法，就是判断返回的object和view有什么关系  一般都是==
- destroy方法，需要传递的参数，一个还是这个object，一个是页面下标
- 轮播图下面的小圆点
- 简单的基本图形，可以用shape根元素类型的xml布局写，放在drawable目录下  然后写一个控制不同基本状态的xml 
- 	一般item里设置enable属性，true和false  设置enable属性的原因是因为在代码里容易控制
- 让小点之间有marging值，是在把小点add到父view时，指定第二个参数layoutprames  要加到哪个类型的布局里，就指定
- 哪种类型的layoutprams
- 要让点随着手指滑动改变，在监听回调中将上一个位置的点设置enable=false	 让当前positon的点设置为true
- activity退出后，里面的handler并没有退出，如果里面有循环，可能内存泄露，所以定义布尔值判断退出否，如果退出
- ondestroy方法要重写。
- onDestroy方法记得要调用super.onDestroy方法
- 自动轮播：getcount Integer.MAX_VALUE	并把用到postion的地方统统改为position=position%list.size()
- popupwindow必须有大小和内容才能使用
- listview的默认背景，有时候就是黑色，很不好看。setBackgroundResource()
- 让点击popupwindow以外的空间后自动隐藏popupwindow：popwindow.setOutsideTouchable(true)
- 解决点击listview某个条目后，字符串不放到EditText里面：设置popwindow的focusable为true。
- popWindow默认不接收焦点
- listview在没有焦点的情况下，默认不响应条目的点击事件
- 这仅仅是listview自己的一个奇怪的现象，和事件响应消费机制无关
- 自定义view需要四步骤:构造方法、测量大小onMeasure、确定位置onLayout、确定内容onDraw
- 自定义view注意bug，很容易有
- 每一个view都有两套大小：一套是自己想要多大，一套是实际显示为多大，有时候相同，有时候不同
- 自身的大小，在setMeasuredDimenstion()的参数里给定。
- 写完onDraw方法，不需要运行，直接在xml视图中即可预览
- 不在布局文件里的图片资源，要找到位置，和引用结合起来，需要用BitmapFactory.decodeResource(getResources,R.drawable.slide_button)
- 在画布上绘制已经画好的图片资源：canvas.drawBitmap
- 画笔有个方法，效果是抗锯齿，setAntiAlias(true)
- 画笔如果可复用，可放在init方法里
- 绘制图片，也可以指定参数，根据需求按照时间变化
- onDraw方法由系统调用，手工调用是invalidate()，作用就是刷新页面
- 要处理触摸事件，就重写onTouchEvent方法，返回true
- click事件也是从touch里面解析出来的，只有有down和up事件，都认为是click事件
- ACTION_MOVE事件是不断发生的
- 注释掉super.onTouchEvent方法，就废掉了onclick点击事件的处理。
- 让按钮有磁性，靠近哪一侧就自动跑到哪一侧，主要是在ACTION_UP里判断slideMax/2与移动距离的关系。前者大于后者，移动到左边。前者小于后者，移动到右边。
- click事件和touch事件冲突，鼠标在哪里抬起，响应哪里的click事件，和touch事件所期望的可能不同。
- 解决办法：在MOVE时候不断判断DOWN和UP之间是否超过10个像素，如果超过，认为是触摸事件，不进行click。如果不超过，认为是click事件，不进行touch	在UP时判断，并在onclick方法里也判断   新建boolean isDrap
- 这样就可以分开touch事件和click事件
- 自定义属性步骤：
- 1，res\values新建attr.xml	在里面声明自定义属性	参考系统自带的属性声明语法	eclipse没有提示
- 	属性类型有那么几种（PPT中有详细的步骤）
- 2，使用属性，声明其命名空间（有时运气好，才能eclipse联想出来）
- 3，在那个带2个参数的构造方法中，解析这些自定义属性，使其能被认识并正确设置
- 获得一个带有全部属性的对象：对象类型叫TypedArray   获取方式是context.obtainStyledAttributes(attrs,R.styleable.自定义控件类名)
- 系统默认为每个自定义控件的属性设置了一个整型数组，里面是这些自定义属性的引用值，自动存在R.styleable目录下
- 接着，用ta.getDrawable(R.styleable.自定义控件类名_属性名)就可以得到Drawable对象。但一般用BitmapDrawable进行强转。最后用这个对象.getBitmap即可。
- 以上代码可以当做一个固定的模板
- getMeasuredHeight()测量高度  view自身想要的高度
- getHeight()真实高度		view实际的高度
- 屏幕上看到的所有东西，都是onDraw方法中的canvas画出来的
- ViewGroup常用的方法：addView	getChildAt()
- ViewGroup有义务为其子view指定位置，所以必须实现onLayout方法
- scrollBy()是View的方法，任何View都可以平移滑动
- 放在不同res的drawable分辨率文件夹下的图片，即使分辨率一样，也可能在运行时清晰度不同。系统会根据手机的分辨率来适配，对应的正好的图片就正常显示，比手机分辨率高的对应文件夹下的图片，会被压缩至60%，然后再显示。这些都是系统自己进行的。
- 在滑动的时候，ViewGroup以其子view的左上角作为坐标原点和坐标系进行滑动。也就是看起来是屏幕在滑动。
- scrollBy方法的意思就是让view发生一些偏移
- scrollTo方法就是直接移动到某个点，并非偏移量
- mScrollX和mScrollY 的意思，就是ViewGroup的位置相对于坐标原点（即子view左上角）的坐标。
- 动画的原理：不断用handler发送延时消息，形成一个循环，在循环里改变坐标值 += 或-=
- 子view的坐标原点就是第一个子view的左上角
- invalidate会调用computeScroll()方法		在这个方法里计算下一时刻的改变，并调用invalidate
- 如果觉得时间的长短把握不好，可以以像素值代替时间，也就是300dp花300ms值，来达到不同距离也是匀速运动的效果
- 系统默认的Scroller类的效果就是不匀速的	ViewPager内部也是使用Scroller的类
- 处理快速滑动的逻辑，在自定义view里面重写onFling方法。
- 但事件和普通滑动事件会冲突：设置标识来记录isFling	然后在移动方法里判断，如果是true，则进行Fling  false
- 则普通滑动		isFling的重置，放在ACTION_UP ACTION_DOWN的哪一个都可以
- Radiogroup默认是竖直排列	
- 让radioGroup中只有一个被选中：设置每一个radiobutton的ID，都是唯一的，然后radiogroup.check(id);这样就只有一个被选中
- ID值只要一个父view 的同级子view的ID彼此独立，是唯一的就可以了
- 这样的好处，radiobutton如果也要和下面的图片轮播起来，直接checkedID就是index，直接移动到Index的图片页面即可
- 系统所有的控件都有监听
- view要想显示出来非常简单，不需要多加别的步骤。但ViewGroup就必须做两个工作：测量所有子view的大小onMeasure、测量所有子view的位置onLayout
- 如果不测量大小，那么所有子view的大小就是0，也就是它想要的大小就是0，也就不给它们指定位置了，所以就显示不出来，只有背景色
- int的最大值是21亿
- 系统在onMeasure的方法里的参数里，传递了两个很大的数。其实是系统把32位的整数拆成最高2位的标志位和30位的实际数字，表示不同意思。如何获取这些标志位和实际数字，系统提供了MeasureSpec.getSize和getMode
- ~1010111  ~是求反的意思		这两个方法原理也是取反后按位相与
- onMeasure方法并不是只执行一次，执行次数还不定。因为要想得到一个view的大小，先要测量它父view的大小，然后看
- 这个view想要多大或者想要的类型，才能确定实际能显示多大。如果父view和子view都是包裹内容，那还得往上找。
- 所以布局的深度不要太深，不要超过十次，否则计算的量太大了
- layout()方法是主动计算，onLayout是指当计算时，需要干什么事。系统的layout方法里，也调用了onLayout方法
- 所以可以让父view在被动计算的同时，子view也layout计算一次自身
- 只有layout()方法执行完后，getWidth()才能得到一个view的准确的值。
- 事件最先是最外层的控件知道的，是屏幕感应到，传递给windowManager的
- 如果从上往下给事件，但每一层都不要这个事件，当事件返回到最上面最初的view后，这个事件就被废掉了
- onTouchEvent，是看每一级要不要这个东西		onInterceptTouchEvent是动用王命旗牌把渠道给强行断掉了，然后再问某些级要不要这个东西
- 同一级，onInterceptTouchEvent方法先执行，onTouchEvent方法最后执行
- 滑动要防止微小的手指抖动，要加>10dp的条件
- 由于ontouchevent方法不断会执行，所以某些view想获得已经被消费的事件，只需要主动在被消费的事件类型的代码区域调一下onTouchEvent事件即可
- dispatchTouchEvent是分发事件，相当于上级的宣旨的机关，向每一级通知任务。分发事件中才onInterceptTouchEvent
- ，最后才onTouchEvent
- onTouchEvent在ACTION_DOWN时候就被消费了
- Viewgroup是以View数组的形式存储子view的
- ViewGroup的dispatchTouchEvent每一层都要分发 直到最底层view的dispatchTouchEvent方法
- ViewGroup的dispatchTouchEvent方法很简单
- 在分发的时候，会用一个叫target的变量记录分发者，这样就可以很快找到每一层的受用者（让target调用dispatchTouchEvent时，很快）
- 如果同时设置onTouchEvent和onTouchListener，listener优先被使用，onTouchEvent方法不起作用
- 多个listview联动的效果，就是在需要联动的区域里，在onTouchEvent方法里重新分发一次事件给所有子view
- 并且InterceptTouchEvent方法设置为true，意思是自己去处理，不交给子view处理   就好像中央拿走了所有权利，需要
- 下属做事的时候，将命令打印多份，分别给每一个下属
- 大一点的公司，好一点的公司，基本都是自己写代码，从来不用第三方框架
- 要想成为编程高手，事件分发是必须要掌握的，绕不过去的坎
- Style.STROKE 设置画笔style时使用，指画线条
- 画笔的setAlpha  255是表示完全不透明		0表示透明
- 透明度始终是0~255  如果为-5，也会认为是250  就像整数-128一样
- 所以，靠近0，就直接把透明度设置为0
- 要想很流畅，一秒50帧
- 水波纹的案例，多个水波纹，每个都是一个对象，放进一个集合里，碰到太近的就不添加进去，然后独立地遍历地开启动画，就能达到效果

- 